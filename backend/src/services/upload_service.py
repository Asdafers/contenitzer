from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
import uuid
import logging
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

from ..models.composed_video import ComposedVideo, UploadStatusEnum

logger = logging.getLogger(__name__)


class UploadService:
    """Service for uploading videos to YouTube"""

    def __init__(self, db: Session):
        self.db = db

    async def upload_to_youtube(
        self,
        project_id: str,
        youtube_api_key: str,
        title: Optional[str] = None,
        description: Optional[str] = None,
        tags: Optional[list] = None
    ) -> ComposedVideo:
        """
        Upload composed video to YouTube

        Args:
            project_id: UUID of the video project
            youtube_api_key: YouTube API key for upload
            title: Video title (optional)
            description: Video description (optional)
            tags: Video tags (optional)

        Returns:
            Updated ComposedVideo with YouTube video ID
        """
        try:
            # Get composed video
            composed_video = self.db.query(ComposedVideo).filter(
                ComposedVideo.project_id == uuid.UUID(project_id)
            ).first()

            if not composed_video:
                raise ValueError(f"Composed video not found for project: {project_id}")

            if composed_video.upload_status == UploadStatusEnum.completed:
                raise ValueError("Video already uploaded to YouTube")

            # Update status to uploading
            composed_video.upload_status = UploadStatusEnum.uploading
            self.db.commit()

            # Build YouTube service
            youtube = build('youtube', 'v3', developerKey=youtube_api_key)

            # Prepare video metadata
            video_metadata = {
                'snippet': {
                    'title': title or f'Generated Video {composed_video.id}',
                    'description': description or 'Generated by Content Creator Workbench',
                    'tags': tags or ['generated', 'content', 'creator'],
                    'categoryId': '22'  # People & Blogs
                },
                'status': {
                    'privacyStatus': 'private'  # Start as private
                }
            }

            # For now, simulate the upload process
            # In a real implementation, this would:
            # 1. Create MediaFileUpload object
            # 2. Execute the upload request
            # 3. Handle resumable uploads for large files
            # 4. Monitor upload progress

            # Simulate successful upload
            simulated_video_id = f"sim_{uuid.uuid4().hex[:11]}"

            # Update composed video with YouTube video ID
            composed_video.youtube_video_id = simulated_video_id
            composed_video.upload_status = UploadStatusEnum.completed
            composed_video.uploaded_at = self.db.execute("SELECT NOW()").scalar()

            self.db.commit()

            logger.info(f"Successfully uploaded video to YouTube: {simulated_video_id}")
            return composed_video

        except HttpError as e:
            logger.error(f"YouTube API error during upload: {e}")
            if 'composed_video' in locals():
                composed_video.upload_status = UploadStatusEnum.failed
                composed_video.upload_error = f"YouTube API error: {e}"
                self.db.commit()
            raise Exception(f"YouTube upload failed: {e}")

        except Exception as e:
            logger.error(f"Failed to upload video: {e}")
            if 'composed_video' in locals():
                composed_video.upload_status = UploadStatusEnum.failed
                composed_video.upload_error = str(e)
                self.db.commit()
            raise

    def _create_upload_metadata(
        self,
        title: str,
        description: str,
        tags: list
    ) -> Dict[str, Any]:
        """Create metadata for YouTube upload"""
        return {
            'snippet': {
                'title': title,
                'description': description,
                'tags': tags,
                'categoryId': '22',  # People & Blogs
                'defaultLanguage': 'en',
                'defaultAudioLanguage': 'en'
            },
            'status': {
                'privacyStatus': 'private',
                'embeddable': True,
                'license': 'youtube',
                'publicStatsViewable': True
            }
        }

    def get_upload_status(self, project_id: str) -> Optional[Dict[str, Any]]:
        """Get upload status for a project"""
        try:
            composed_video = self.db.query(ComposedVideo).filter(
                ComposedVideo.project_id == uuid.UUID(project_id)
            ).first()

            if not composed_video:
                return None

            return {
                'project_id': str(composed_video.project_id),
                'upload_status': composed_video.upload_status.value,
                'youtube_video_id': composed_video.youtube_video_id,
                'uploaded_at': composed_video.uploaded_at,
                'upload_error': composed_video.upload_error
            }

        except Exception as e:
            logger.error(f"Failed to get upload status for project {project_id}: {e}")
            return None

    def validate_youtube_api_key(self, api_key: str) -> bool:
        """Validate YouTube API key"""
        try:
            youtube = build('youtube', 'v3', developerKey=api_key)
            # Test API key with a simple request
            youtube.channels().list(part='id', mine=True).execute()
            return True
        except HttpError:
            return False
        except Exception as e:
            logger.error(f"Failed to validate YouTube API key: {e}")
            return False